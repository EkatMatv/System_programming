"""
Часть 1. Последовательное выполнение (await)
Напишите функцию async def do_work(name, delay), которая:
печатает сообщение о начале работы;
делает await asyncio.sleep(delay);
печатает сообщение о завершении;
возвращает имя задачи.
Напишите функцию async def sequential_demo(), которая вызывает do_work("A", 2) и do_work("B", 1) последовательно с помощью await.
Замерьте общее время выполнения этой функции (используйте time.perf_counter).

Вопрос:
Сколько времени заняла программа?
Почему выполнение заняло именно столько времени?

Общее время выполнения: ~3 секунды
Последовательное выполнение (await) означает, что задачи выполняются строго одна за другой
Сначала выполняется do_work("A", 2) с задержкой 2 секунды
Только после полного завершения первой задачи начинает выполняться do_work("B", 1) с задержкой 1 секунду
Общее время = 2 секунды (задача A) + 1 секунда (задача B) = 3 секунды
"""
import asyncio
import time
async def do_work(name, delay):
    print(f"Начало работы с {name}")
    await asyncio.sleep(delay)
    print(f"Завершение работы с {name}")
    return name

async def sequential_demo():
    start = time.perf_counter()
    await do_work("A", 2)
    await do_work("B", 1)
    end = time.perf_counter()
    print(f"Время выполнения: {end - start:.2f} секунд")
#asyncio.run(sequential_demo())

"""
Часть 2. Запуск через create_task
Напишите функцию async def tasks_demo(), в которой:
создайте две задачи task1 и task2 через asyncio.create_task;
сразу после запуска выведите сообщение «Задачи запущены»;
дождитесь завершения обеих задач через await task1 и await task2.
Замерьте общее время выполнения.

Вопрос:
Чем отличается вывод программы от последовательного запуска?
Почему общее время меньше?

Общее время выполнения: ~2 секунды
Отличия от последовательного запуска:
Параллельное выполнение - задачи запускаются одновременно
Порядок вывода отличается:
Сначала выводятся оба сообщения о начале работы
Затем сообщения о завершении появляются по мере готовности
"""
async def tasks_demo():
    start = time.perf_counter()
    task1 = asyncio.create_task(do_work("A", 2))
    task2 = asyncio.create_task(do_work("B", 1))
    print("Задачи запущены")
    await task1
    await task2
    end = time.perf_counter()
    print(f"Время выполнения: {end - start:.2f} секунд")

#asyncio.run(tasks_demo())
"""
Часть 3. Использование asyncio.gather
Напишите функцию async def gather_demo(), которая запускает do_work("A", 2) и do_work("B", 1) с помощью asyncio.gather.
Замерьте время выполнения и сравните его с предыдущими частями.

Вопрос:
Чем gather отличается от ручного создания задач?
В каких случаях gather удобнее?

Общее время выполнения: ~2 секунды (такое же, как с create_task)
Автоматическое ожидание всех задач - не нужно писать отдельные await для каждой
Сравнение подходов:
sequential_demo(): 3 секунды (последовательно)
tasks_demo(): 2 секунды (параллельно, ручное управление)
gather_demo(): 2 секунды (параллельно, автоматическое управление)
Gather идеален для сценариев "запусти все и дождись всех результатов", 
в то время как create_task дает больше контроля над отдельными задачами.
"""
async def gather_demo():
    start = time.perf_counter()
    await asyncio.gather(
        do_work("A", 2),
        do_work("B", 1)
    )
    end = time.perf_counter()
    print(f"Время выполнения: {end - start:.2f} секунд")

#asyncio.run(gather_demo())
"""
Часть 4. задание
Добавьте третью задачу do_work("C", 3).
Сравните выполнение при:
последовательном await,
ручном create_task,
использовании gather.
Постройте таблицу:

Метод	Общее время выполнения	Порядок завершения задач
await	
create_task
gather

Таблица сравнения:

Метод	Общее время выполнения	Порядок завершения задач
await	          ~6 секунд	        A → B → C
create_task	      ~3 секунд	        B → A → C
gather	          ~3 секунд	        B → A → C
Объяснение:

Последовательный await (6 секунд):
Задачи выполняются строго по очереди: A(2с) + B(1с) + C(3с) = 6 секунд
Порядок: A начинает → A завершает → B начинает → B завершает → C начинает → C завершает

create_task (3 секунды):
Все задачи запускаются одновременно
Общее время определяется самой долгой задачей (C - 3 секунды)
Порядок завершения: B(1с) → A(2с) → C(3с)

gather (3 секунды):
Аналогично create_task, все задачи выполняются параллельно
Общее время = максимальная задержка (3 секунды)
Порядок завершения: B(1с) → A(2с) → C(3с)
"""
async def sequential_three():
    start = time.perf_counter()
    await do_work("A", 2)
    await do_work("B", 1)
    await do_work("C", 3)
    end = time.perf_counter()
    print(f"Время выполнения: {end - start:.2f} секунд")

async def tasks_three():
    start = time.perf_counter()
    t1 = asyncio.create_task(do_work("A", 2))
    t2 = asyncio.create_task(do_work("B", 1))
    t3 = asyncio.create_task(do_work("C", 3))
    print("Задачи запущены")
    await t1
    await t2
    await t3
    end = time.perf_counter()
    print(f"Время выполнения: {end - start:.2f} секунд")

async def gather_demo():
    start = time.perf_counter()
    await asyncio.gather(
        do_work("A", 2),
        do_work("B", 1),
        do_work("C", 3)
    )
    end = time.perf_counter()
    print(f"Время выполнения: {end - start:.2f} секунд")

async def main():
    await sequential_three()
    await tasks_three()
    await gather_demo()

asyncio.run(main())
"""
Часть 5. Вопросы
Почему await в последовательном варианте не дал конкурентности?
Потому что await блокирует выполнение до полного завершения текущей задачи. 

В чём разница между create_task и gather?
create_task:
Запускает одну задачу в фоновом режиме
Возвращает объект Task для ручного управления
Требует явного await для каждой задачи
Дает больше контроля над отдельными задачами
gather:
Запускает несколько задач одновременно
Автоматически ожидает завершения всех задач
Возвращает упорядоченный список результатов
Имеет встроенную обработку ошибок через return_exceptions
Аналогия: create_task - как нанять отдельных работников и самому ими управлять, 
gather - как отдать список поручений менеджеру и получить все результаты сразу.

Почему asyncio.run обычно вызывается только один раз в программе?
asyncio.run() создает новый event loop
Запускает его и управляет жизненным циклом
После завершения закрывает loop
Повторный вызов создаст новый loop, что может привести к:
Утечкам ресурсов
Конфликтам между loop'ами
Непредсказуемому поведению
Правильный подход: одна точка входа asyncio.run(main()), 
где main() запускает все необходимые корутины.

Как вы объясните словами: «где именно происходит асинхронность»?
Асинхронность происходит в момент await когда:
Корутина встречает операцию ожидания (I/O, sleep, сетевой запрос)
Event loop приостанавливает текущую задачу и освобождает поток
Переключается на другую готовую к выполнению задачу
Когда операция завершается, задача возвращается в очередь на выполнение
Простая аналогия: Как официант в ресторане - он принимает заказ (запускает задачу), 
пока еда готовится (await), он обслуживает других клиентов 
(переключается на другие задачи), а когда еда готова (операция завершена), 
возвращается к первому клиенту.
"""
